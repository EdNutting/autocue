<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autocue</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600&family=Inter:wght@400;500;600&family=Playfair+Display:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --font-size: 48px;
            --font-family: "Crimson Pro", Georgia, serif;
            --line-height: 1.6;
            --text-color: #FFFFFF;
            --dim-color: #555555;
            --highlight-color: #FFD700;
            --bg-color: #0a0a0a;
            --past-lines: 1;
        }

        body {
            font-family: var(--font-family);
            font-size: var(--font-size);
            line-height: var(--line-height);
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
            transition: background-color 0.3s ease;
        }

        /* Editor Mode */
        #editor-container {
            display: flex;
            height: 100vh;
            background: #111;
        }

        #editor-panel {
            flex: 1;
            padding: 24px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #333;
        }

        #settings-panel {
            width: 320px;
            padding: 24px;
            overflow-y: auto;
            background: #0d0d0d;
        }

        #script-input {
            flex: 1;
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            color: #fff;
            font-family: "Inter", sans-serif;
            font-size: 16px;
            line-height: 1.6;
            padding: 20px;
            resize: none;
            outline: none;
        }

        #script-input:focus {
            border-color: #555;
        }

        #script-input::placeholder {
            color: #666;
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .editor-title {
            font-family: "Inter", sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn {
            font-family: "Inter", sans-serif;
            font-size: 14px;
            font-weight: 500;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #FFD700;
            color: #000;
        }

        .btn-primary:hover {
            background: #FFED4A;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #333;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #444;
        }

        .settings-section {
            margin-bottom: 28px;
        }

        .settings-title {
            font-family: "Inter", sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 14px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
        }

        .setting-label {
            font-family: "Inter", sans-serif;
            font-size: 13px;
            color: #aaa;
        }

        .setting-input {
            width: 80px;
            padding: 6px 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-family: "Inter", sans-serif;
            font-size: 13px;
            text-align: right;
        }

        .setting-select {
            padding: 6px 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-family: "Inter", sans-serif;
            font-size: 13px;
        }

        .color-input {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Prompter Mode */
        #prompter-container {
            display: none;
            height: 100vh;
            flex-direction: column;
            justify-content: flex-start;
            padding: 5vh 10vw;
            position: relative;
            overflow-y: auto;
        }

        #prompter-container.active {
            display: flex;
        }

        #script-display {
            max-height: 80vh;
            overflow-y: auto;
            padding-bottom: 40vh;
        }

        #script-display p {
            margin: 0.3em 0;
        }

        #editor-container.hidden {
            display: none;
        }

        .script-line {
            transition: all 0.15s ease-out;
            padding: 0.1em 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .script-line.past {
            color: var(--dim-color);
            opacity: 0.5;
        }

        .script-line.current {
            color: var(--highlight-color);
            font-weight: 600;
        }

        .script-line.future {
            color: var(--text-color);
        }

        .word {
            display: inline;
            transition: color 0.1s ease;
            cursor: pointer;
        }

        .word:hover {
            text-decoration: underline;
            text-underline-offset: 4px;
        }

        .word.spoken {
            color: var(--dim-color);
        }

        .word.current {
            color: var(--highlight-color);
            text-decoration: underline;
            text-underline-offset: 4px;
        }

        /* Markdown styles for prompter */
        #script-display h1,
        #script-display h2,
        #script-display h3,
        #script-display h4,
        #script-display h5,
        #script-display h6 {
            margin: 0.3em 0;
            font-weight: 600;
        }

        #script-display h1 { font-size: 1.4em; }
        #script-display h2 { font-size: 1.25em; }
        #script-display h3 { font-size: 1.1em; }

        #script-display strong,
        #script-display b {
            font-weight: 600;
        }

        #script-display em,
        #script-display i {
            font-style: italic;
        }

        #script-display ul,
        #script-display ol {
            margin: 0.2em 0;
            padding-left: 1.5em;
        }

        #script-display li {
            margin: 0.1em 0;
        }

        #script-display blockquote {
            border-left: 3px solid var(--highlight-color);
            padding-left: 0.8em;
            margin: 0.3em 0;
            opacity: 0.9;
        }

        #script-display code {
            font-family: monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.1em 0.3em;
            border-radius: 3px;
        }

        #script-display hr {
            border: none;
            border-top: 1px solid var(--dim-color);
            margin: 0.5em 0;
        }

        /* Progress bar */
        #progress-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            height: 4px;
            background: var(--highlight-color);
            transition: width 0.2s ease;
            opacity: 0.8;
        }

        /* Status indicator */
        #status {
            position: fixed;
            top: 20px;
            right: 20px;
            font-family: "Inter", sans-serif;
            font-size: 12px;
            padding: 8px 14px;
            background: rgba(0,0,0,0.7);
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.listening {
            background: #4CAF50;
            animation: pulse 1.5s infinite;
        }

        .status-dot.backtrack {
            background: #FF9800;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Exit button */
        #exit-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: "Inter", sans-serif;
            font-size: 12px;
            padding: 8px 14px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 20px;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #exit-btn:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        /* Transcript toggle button */
        #transcript-btn {
            position: fixed;
            top: 20px;
            left: 100px;
            font-family: "Inter", sans-serif;
            font-size: 12px;
            padding: 8px 14px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 20px;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #transcript-btn:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        #transcript-btn.recording {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        #transcript-btn.recording:hover {
            background: rgba(244, 67, 54, 0.4);
        }

        .record-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
        }

        .record-dot.active {
            background: #f44336;
            animation: pulse 1s infinite;
        }

        /* Transcript display */
        #transcript {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            font-family: "Inter", sans-serif;
            font-size: 14px;
            color: #666;
            text-align: center;
            max-height: 60px;
            overflow: hidden;
        }

        /* Loading spinner overlay */
        #loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 10, 0.95);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 24px;
        }

        #loading-overlay.visible {
            display: flex;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255, 215, 0, 0.2);
            border-top-color: #FFD700;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: "Inter", sans-serif;
            font-size: 16px;
            color: #aaa;
            text-align: center;
        }

        .loading-model {
            font-family: "Inter", sans-serif;
            font-size: 13px;
            color: #666;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Editor Mode -->
    <div id="editor-container">
        <div id="editor-panel">
            <div class="editor-header">
                <span class="editor-title">Script (Markdown supported)</span>
                <div style="display: flex; gap: 12px; align-items: center;">
                    <select class="setting-select" id="sample-select" style="min-width: 180px;">
                        <option value="">Load sample script...</option>
                    </select>
                    <button class="btn btn-primary" onclick="startPrompter()">Start Prompter</button>
                </div>
            </div>
            <textarea id="script-input" placeholder="Paste your script here...

You can use **Markdown** formatting:
- Headers with #
- **Bold** and *italic*
- Lists and paragraphs

The prompter will track your speech and scroll automatically."></textarea>
        </div>

        <div id="settings-panel">
            <div class="settings-section">
                <div class="settings-title">Typography</div>
                <div class="setting-row">
                    <span class="setting-label">Font Size</span>
                    <input type="number" class="setting-input" id="setting-fontSize" value="48" min="24" max="120">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Font</span>
                    <select class="setting-select" id="setting-fontFamily">
                        <option value='"Crimson Pro", Georgia, serif'>Crimson Pro</option>
                        <option value='"Playfair Display", Georgia, serif'>Playfair Display</option>
                        <option value='Georgia, serif'>Georgia</option>
                        <option value='"Inter", sans-serif'>Inter</option>
                        <option value='system-ui, sans-serif'>System</option>
                    </select>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Line Height</span>
                    <input type="number" class="setting-input" id="setting-lineHeight" value="1.6" min="1" max="3" step="0.1">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Display</div>
                <div class="setting-row">
                    <span class="setting-label">Past Lines</span>
                    <input type="number" class="setting-input" id="setting-pastLines" value="1" min="0" max="5">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Future Lines</span>
                    <input type="number" class="setting-input" id="setting-futureLines" value="8" min="3" max="20">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Recording</div>
                <div class="setting-row">
                    <span class="setting-label">Save Transcript</span>
                    <input type="checkbox" id="setting-saveTranscript" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Audio Device</div>
                <div class="setting-row" style="flex-direction: column; align-items: flex-start; gap: 8px;">
                    <span class="setting-label">Input Device</span>
                    <select class="setting-select" id="audio-device-select" style="width: 100%;">
                        <option value="">Loading devices...</option>
                    </select>
                    <span id="audio-device-status" style="font-family: 'Inter', sans-serif; font-size: 11px; color: #666;"></span>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Transcription</div>
                <div class="setting-row" style="flex-direction: column; align-items: flex-start; gap: 8px;">
                    <span class="setting-label">Provider</span>
                    <select class="setting-select" id="transcription-provider-select" style="width: 100%;">
                        <option value="vosk">Vosk</option>
                        <option value="sherpa">Sherpa-ONNX</option>
                    </select>
                </div>
                <div class="setting-row" style="flex-direction: column; align-items: flex-start; gap: 8px;">
                    <span class="setting-label">Model</span>
                    <select class="setting-select" id="transcription-model-select" style="width: 100%;">
                        <option value="">Loading models...</option>
                    </select>
                    <span id="transcription-status" style="font-family: 'Inter', sans-serif; font-size: 11px; color: #666;"></span>
                    <div id="model-download-progress" style="display: none; width: 100%; margin-top: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span id="model-download-stage" style="font-family: 'Inter', sans-serif; font-size: 11px; color: #888;">Downloading...</span>
                            <span id="model-download-percent" style="font-family: 'Inter', sans-serif; font-size: 11px; color: #888;">0%</span>
                        </div>
                        <div style="width: 100%; height: 4px; background: #333; border-radius: 2px; overflow: hidden;">
                            <div id="model-download-bar" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Colors</div>
                <div class="setting-row">
                    <span class="setting-label">Highlight</span>
                    <input type="color" class="color-input" id="setting-highlightColor" value="#FFD700">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Text</span>
                    <input type="color" class="color-input" id="setting-textColor" value="#FFFFFF">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Dim</span>
                    <input type="color" class="color-input" id="setting-dimColor" value="#555555">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Background</span>
                    <input type="color" class="color-input" id="setting-backgroundColor" value="#0a0a0a">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Keyboard Shortcuts</div>
                <div class="setting-row">
                    <span class="setting-label" style="color: #666;">Escape</span>
                    <span class="setting-label">Exit prompter</span>
                </div>
                <div class="setting-row">
                    <span class="setting-label" style="color: #666;">Space</span>
                    <span class="setting-label">Pause/Resume</span>
                </div>
                <div class="setting-row">
                    <span class="setting-label" style="color: #666;">R</span>
                    <span class="setting-label">Reset to start</span>
                </div>
            </div>

            <div class="settings-section">
                <button class="btn btn-secondary" id="save-config-btn" onclick="saveConfig()" style="width: 100%;">Save as Default</button>
                <div id="save-status" style="font-family: 'Inter', sans-serif; font-size: 12px; color: #666; margin-top: 8px; text-align: center;"></div>
            </div>
        </div>
    </div>

    <!-- Prompter Mode -->
    <div id="prompter-container">
        <div id="script-display"></div>
        <div id="progress-bar" style="width: 0%"></div>
        <div id="status">
            <span class="status-dot listening"></span>
            <span id="status-text">Listening...</span>
        </div>
        <button id="exit-btn" onclick="exitPrompter()">‚Üê Exit</button>
        <button id="transcript-btn" onclick="toggleTranscript()">
            <span class="record-dot"></span>
            <span id="transcript-btn-text">Transcribe</span>
        </button>
        <div id="transcript"></div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading transcription model...</div>
        <div class="loading-model" id="loading-model-name"></div>
    </div>

    <script>
        let ws = null;
        let totalWords = 0;  // Set by server
        let currentWordIndex = 0;
        let settings = {};
        let isPaused = false;
        let scriptHtml = '';  // Pre-indexed HTML from server
        let isRecordingTranscript = false;  // Transcript recording state
        let audioDevices = [];  // Available audio devices
        let currentAudioDevice = null;  // Currently selected audio device index
        let transcriptionModels = [];  // Available transcription models
        let currentTranscriptionConfig = null;  // Current transcription configuration
        let waitingForModelLoad = false;  // Track if we're waiting for model to load

        // Connect WebSocket
        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => console.log('WebSocket connected');
            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(connect, 1000);
            };
            ws.onerror = (e) => console.error('WebSocket error:', e);

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
        }

        function handleMessage(data) {
            switch (data.type) {
                case 'init':
                    document.getElementById('script-input').value = data.script || '';
                    scriptHtml = data.scriptHtml || '';
                    totalWords = data.totalWords || 0;
                    settings = data.settings || {};
                    applySettings(settings);
                    // Populate sample scripts dropdown
                    populateSamples(data.samples || []);
                    // Store current audio device
                    currentAudioDevice = data.audioDevice;
                    // Fetch and populate audio devices
                    fetchAudioDevices();
                    // Store transcription config and fetch models
                    currentTranscriptionConfig = data.transcriptionConfig;
                    if (currentTranscriptionConfig) {
                        document.getElementById('transcription-provider-select').value = currentTranscriptionConfig.provider;
                    }
                    fetchTranscriptionModels();
                    break;

                case 'script_updated':
                    document.getElementById('script-input').value = data.script;
                    scriptHtml = data.scriptHtml || '';
                    totalWords = data.totalWords || 0;
                    // If we were waiting to start the prompter, activate it now
                    // (unless we're waiting for the model to load)
                    if (waitingForScript && !waitingForModelLoad) {
                        waitingForScript = false;
                        activatePrompterMode();
                    }
                    break;

                case 'settings_updated':
                    settings = data.settings;
                    applySettings(settings);
                    break;

                case 'position':
                    updatePosition(data);
                    break;

                case 'reset':
                    resetDisplay();
                    break;

                case 'jump_to':
                    jumpToWord(data.wordIndex);
                    break;

                case 'config_saved': {
                        const statusEl = document.getElementById('save-status');
                        if (data.success) {
                            statusEl.textContent = 'Settings saved!';
                            statusEl.style.color = '#4CAF50';
                        } else {
                            statusEl.textContent = 'Failed to save: ' + (data.error || 'Unknown error');
                            statusEl.style.color = '#f44336';
                        }
                        setTimeout(() => { statusEl.textContent = ''; }, 3000);
                    }
                    break;

                case 'transcript_status':
                    updateTranscriptUI(data.recording, data.file);
                    break;

                case 'audio_device_updated': {
                        const statusEl = document.getElementById('audio-device-status');
                        if (data.success) {
                            currentAudioDevice = data.deviceIndex;
                            statusEl.textContent = 'Device updated. Restart prompter to use new device.';
                            statusEl.style.color = '#4CAF50';
                        } else {
                            statusEl.textContent = 'Failed to update: ' + (data.error || 'Unknown error');
                            statusEl.style.color = '#f44336';
                        }
                        setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    }
                    break;

                case 'transcription_models':
                    transcriptionModels = data.models || [];
                    const provider = document.getElementById('transcription-provider-select').value;
                    populateTranscriptionModels(provider);
                    break;

                case 'transcription_config_updated': {
                        const statusEl = document.getElementById('transcription-status');
                        if (data.success) {
                            statusEl.textContent = data.message || 'Settings saved. Stop and start prompting to apply.';
                            statusEl.style.color = '#4CAF50';
                        } else {
                            statusEl.textContent = data.error || 'Failed to save settings';
                            statusEl.style.color = '#f44336';
                        }
                        setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    }
                    break;

                case 'model_download_status':
                    handleModelDownloadStatus(data);
                    break;

                case 'model_download_progress':
                    handleModelDownloadProgress(data);
                    break;

                case 'model_download_complete':
                    handleModelDownloadComplete(data);
                    break;

                case 'model_loading_status':
                    handleModelLoadingStatus(data);
                    break;
            }
        }

        function updateTranscriptUI(recording, file) {
            isRecordingTranscript = recording;
            const btn = document.getElementById('transcript-btn');
            const btnText = document.getElementById('transcript-btn-text');
            const dot = btn.querySelector('.record-dot');
            const checkbox = document.getElementById('setting-saveTranscript');

            if (recording) {
                btn.classList.add('recording');
                dot.classList.add('active');
                btnText.textContent = 'Transcribing';
                if (checkbox) checkbox.checked = true;
            } else {
                btn.classList.remove('recording');
                dot.classList.remove('active');
                btnText.textContent = 'Transcribe';
                if (checkbox) checkbox.checked = false;
            }
        }

        function toggleTranscript() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'toggle_transcript',
                    enable: !isRecordingTranscript
                }));
            }
        }

        function applySettings(s) {
            const root = document.documentElement;
            root.style.setProperty('--font-size', s.fontSize + 'px');
            root.style.setProperty('--font-family', s.fontFamily);
            root.style.setProperty('--line-height', s.lineHeight);
            root.style.setProperty('--highlight-color', s.highlightColor);
            root.style.setProperty('--text-color', s.textColor);
            root.style.setProperty('--dim-color', s.dimColor);
            root.style.setProperty('--bg-color', s.backgroundColor);

            // Update input values
            for (const [key, value] of Object.entries(s)) {
                const el = document.getElementById('setting-' + key);
                if (el) el.value = value;
            }
        }

        function getSettings() {
            return {
                fontSize: parseInt(document.getElementById('setting-fontSize').value),
                fontFamily: document.getElementById('setting-fontFamily').value,
                lineHeight: parseFloat(document.getElementById('setting-lineHeight').value),
                pastLines: parseInt(document.getElementById('setting-pastLines').value),
                futureLines: parseInt(document.getElementById('setting-futureLines').value),
                highlightColor: document.getElementById('setting-highlightColor').value,
                textColor: document.getElementById('setting-textColor').value,
                dimColor: document.getElementById('setting-dimColor').value,
                backgroundColor: document.getElementById('setting-backgroundColor').value
            };
        }

        function saveConfig() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const statusEl = document.getElementById('save-status');
                statusEl.textContent = 'Saving...';
                statusEl.style.color = '#666';
                ws.send(JSON.stringify({ type: 'save_config' }));
            }
        }

        // Flag to indicate we're waiting for server to send indexed HTML
        let waitingForScript = false;

        function startPrompter() {
            const script = document.getElementById('script-input').value.trim();
            if (!script) {
                alert('Please enter a script first');
                return;
            }

            // Send script and settings to server
            // The server will respond with indexed HTML in script_updated message
            settings = getSettings();
            waitingForScript = true;

            // Get transcript preference
            const saveTranscript = document.getElementById('setting-saveTranscript').checked;

            // Send script to load it (without saveTranscript, as we'll send start_prompting separately)
            ws.send(JSON.stringify({ type: 'script', text: script }));
            ws.send(JSON.stringify({ type: 'settings', settings: settings }));

            // Send start_prompting to initialize audio and transcriber
            ws.send(JSON.stringify({ type: 'start_prompting', saveTranscript: saveTranscript }));
        }

        function activatePrompterMode() {
            // Switch to prompter mode
            document.getElementById('editor-container').classList.add('hidden');
            document.getElementById('prompter-container').classList.add('active');

            // Initial render using server-provided indexed HTML
            currentWordIndex = 0;
            renderScriptByWordIndex(0);

            // Apply settings
            applySettings(settings);
        }

        function exitPrompter() {
            // Send stop_prompting to cleanup audio and transcriber
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'stop_prompting' }));
            }

            document.getElementById('editor-container').classList.remove('hidden');
            document.getElementById('prompter-container').classList.remove('active');
        }

        function renderScriptByWordIndex(wordIndex) {
            const display = document.getElementById('script-display');

            // Render the pre-indexed HTML from server
            display.innerHTML = scriptHtml;

            // Update word styling based on current position
            display.querySelectorAll('.word').forEach(el => {
                const wordIdx = parseInt(el.dataset.wordIndex, 10);
                el.classList.remove('spoken', 'current');

                if (wordIdx < wordIndex) {
                    el.classList.add('spoken');
                } else if (wordIdx === wordIndex) {
                    el.classList.add('current');
                }

                // Add click handler
                el.addEventListener('click', handleWordClick);
            });

            // Scroll the current word into view
            const currentEl = display.querySelector('.word.current');
            if (currentEl) {
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function handleWordClick(e) {
            const wordIndex = parseInt(e.target.dataset.wordIndex, 10);
            if (!isNaN(wordIndex)) {
                ws.send(JSON.stringify({ type: 'jump_to', wordIndex: wordIndex }));
            }
        }

        function jumpToWord(wordIndex) {
            currentWordIndex = wordIndex;
            renderScriptByWordIndex(wordIndex);

            // Update progress bar
            const progress = totalWords > 0 ? (wordIndex / totalWords) * 100 : 0;
            document.getElementById('progress-bar').style.width = progress + '%';
        }

        function updatePosition(data) {
            if (isPaused) return;

            // Use wordIndex directly - no line/offset conversion needed
            // since we use server-provided word indices in the HTML
            currentWordIndex = data.wordIndex;
            renderScriptByWordIndex(data.wordIndex);

            // Report what word we're highlighting back to server for debugging
            const currentEl = document.querySelector('.word.current');
            if (currentEl && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'frontend_highlight',
                    wordIndex: data.wordIndex,
                    word: currentEl.textContent,
                    sourceLine: data.lineIndex,
                    sourceOffset: data.wordOffset,
                    serverWordIndex: data.wordIndex
                }));
            }

            // Update progress bar
            const progress = totalWords > 0 ? (data.wordIndex / totalWords) * 100 : 0;
            document.getElementById('progress-bar').style.width = progress + '%';

            // Update status
            const dot = document.querySelector('.status-dot');
            const statusText = document.getElementById('status-text');

            if (data.isBacktrack) {
                dot.className = 'status-dot backtrack';
                statusText.textContent = 'Backtrack detected';
                setTimeout(() => {
                    dot.className = 'status-dot listening';
                    statusText.textContent = 'Listening...';
                }, 1000);
            } else if (data.confidence > 70) {
                dot.className = 'status-dot listening';
                statusText.textContent = 'Listening...';
            }

            // Show transcript
            if (data.transcript) {
                document.getElementById('transcript').textContent = data.transcript;
            }
        }

        function resetDisplay() {
            currentWordIndex = 0;
            renderScriptByWordIndex(0);
            document.getElementById('progress-bar').style.width = '0%';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('prompter-container').classList.contains('active')) {
                return;
            }

            switch (e.key) {
                case 'Escape':
                    exitPrompter();
                    break;
                case ' ':
                    e.preventDefault();
                    isPaused = !isPaused;
                    document.getElementById('status-text').textContent = isPaused ? 'Paused' : 'Listening...';
                    break;
                case 'r':
                case 'R':
                    ws.send(JSON.stringify({ type: 'reset' }));
                    resetDisplay();
                    break;
            }
        });

        // Populate sample scripts dropdown
        function populateSamples(samples) {
            const select = document.getElementById('sample-select');
            // Clear existing options except the first placeholder
            while (select.options.length > 1) {
                select.remove(1);
            }
            // Add sample options
            samples.forEach(sample => {
                const option = document.createElement('option');
                option.value = sample.filename;
                option.textContent = sample.name;
                select.appendChild(option);
            });
        }

        // Sample script selection handler
        document.getElementById('sample-select').addEventListener('change', (e) => {
            const filename = e.target.value;
            if (filename && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'load_sample', filename: filename }));
            }
            // Reset dropdown to placeholder
            e.target.value = '';
        });

        // Fetch audio devices from backend
        async function fetchAudioDevices() {
            try {
                const response = await fetch('/audio-devices');
                const data = await response.json();
                if (data.status === 'ok') {
                    audioDevices = data.devices;
                    populateAudioDevices();
                } else {
                    console.error('Failed to fetch audio devices:', data.message);
                    document.getElementById('audio-device-select').innerHTML = '<option value="">Error loading devices</option>';
                }
            } catch (error) {
                console.error('Error fetching audio devices:', error);
                document.getElementById('audio-device-select').innerHTML = '<option value="">Error loading devices</option>';
            }
        }

        // Populate audio devices dropdown
        function populateAudioDevices() {
            const select = document.getElementById('audio-device-select');
            select.innerHTML = '';

            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'System Default';
            select.appendChild(defaultOption);

            // Add device options
            audioDevices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.index;
                option.textContent = device.name;
                select.appendChild(option);
            });

            // Set current selection
            if (currentAudioDevice !== null && currentAudioDevice !== undefined) {
                select.value = currentAudioDevice;
            } else {
                select.value = '';
            }
        }

        // Audio device selection handler
        document.getElementById('audio-device-select').addEventListener('change', (e) => {
            const deviceIndex = e.target.value === '' ? null : parseInt(e.target.value);
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'set_audio_device',
                    deviceIndex: deviceIndex
                }));
            }
        });

        // Fetch transcription models from backend
        function fetchTranscriptionModels() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'get_transcription_models' }));
            }
        }

        // Populate transcription model dropdown based on selected provider
        function populateTranscriptionModels(provider) {
            const select = document.getElementById('transcription-model-select');
            select.innerHTML = '';

            const filtered = transcriptionModels.filter(m => m.provider === provider);
            if (filtered.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No models available';
                select.appendChild(option);
                return;
            }

            filtered.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = `${model.name} (${model.sizeMb}MB)`;
                select.appendChild(option);
            });

            // Select current model if available
            if (currentTranscriptionConfig && currentTranscriptionConfig.provider === provider) {
                select.value = currentTranscriptionConfig.model_id;
            } else if (filtered.length > 0) {
                select.value = filtered[0].id;
            }
        }

        // Transcription provider selection handler
        document.getElementById('transcription-provider-select').addEventListener('change', (e) => {
            populateTranscriptionModels(e.target.value);
        });

        // Transcription model selection handler
        document.getElementById('transcription-model-select').addEventListener('change', (e) => {
            const provider = document.getElementById('transcription-provider-select').value;
            const modelId = e.target.value;

            if (ws && ws.readyState === WebSocket.OPEN) {
                // First check if model is downloaded
                ws.send(JSON.stringify({
                    type: 'check_model_downloaded',
                    provider: provider,
                    modelId: modelId
                }));
            }
        });

        // Handle model download status check
        function handleModelDownloadStatus(data) {
            const provider = data.provider;
            const modelId = data.modelId;
            const downloaded = data.downloaded;

            if (downloaded) {
                // Model is already downloaded, just save the config
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'set_transcription_config',
                        provider: provider,
                        modelId: modelId
                    }));
                }
            } else {
                // Model not downloaded, start download automatically
                const statusEl = document.getElementById('transcription-status');
                statusEl.textContent = 'Model not downloaded. Starting download...';
                statusEl.style.color = '#FFA500';

                // Start download
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'download_model',
                        provider: provider,
                        modelId: modelId
                    }));
                }

                // Show progress bar
                showModelDownloadProgress();
            }
        }

        // Handle model download progress updates
        function handleModelDownloadProgress(data) {
            const stage = data.stage;
            const percent = data.percent;

            // Update progress bar
            const progressContainer = document.getElementById('model-download-progress');
            const stageEl = document.getElementById('model-download-stage');
            const percentEl = document.getElementById('model-download-percent');
            const barEl = document.getElementById('model-download-bar');

            progressContainer.style.display = 'block';

            // Update stage text
            const stageText = {
                'starting': 'Starting download...',
                'downloading': 'Downloading model...',
                'extracting': 'Extracting files...',
                'complete': 'Complete'
            };
            stageEl.textContent = stageText[stage] || stage;
            percentEl.textContent = percent + '%';
            barEl.style.width = percent + '%';
        }

        // Handle model download completion
        function handleModelDownloadComplete(data) {
            const statusEl = document.getElementById('transcription-status');

            if (data.success) {
                statusEl.textContent = data.message || 'Model downloaded. Restart prompter to use it.';
                statusEl.style.color = '#4CAF50';

                // Hide progress bar after a delay
                setTimeout(() => {
                    hideModelDownloadProgress();
                }, 2000);

                // Save the config now that model is downloaded
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'set_transcription_config',
                        provider: data.provider,
                        modelId: data.modelId
                    }));
                }
            } else {
                statusEl.textContent = 'Download failed: ' + (data.error || 'Unknown error');
                statusEl.style.color = '#f44336';
                hideModelDownloadProgress();
            }

            setTimeout(() => {
                if (statusEl.textContent.includes('Restart prompter')) {
                    statusEl.textContent = '';
                }
            }, 10000);
        }

        // Show model download progress bar
        function showModelDownloadProgress() {
            const progressContainer = document.getElementById('model-download-progress');
            progressContainer.style.display = 'block';
            document.getElementById('model-download-stage').textContent = 'Starting...';
            document.getElementById('model-download-percent').textContent = '0%';
            document.getElementById('model-download-bar').style.width = '0%';
        }

        // Hide model download progress bar
        function hideModelDownloadProgress() {
            const progressContainer = document.getElementById('model-download-progress');
            progressContainer.style.display = 'none';
        }

        // Handle model loading status
        function handleModelLoadingStatus(data) {
            const overlay = document.getElementById('loading-overlay');
            const modelNameEl = document.getElementById('loading-model-name');

            if (data.status === 'loading') {
                // Show loading spinner
                waitingForModelLoad = true;
                modelNameEl.textContent = `${data.provider}: ${data.modelId}`;
                overlay.classList.add('visible');
            } else if (data.status === 'ready') {
                // Hide loading spinner and activate prompter
                waitingForModelLoad = false;
                overlay.classList.remove('visible');
                // Now that model is ready, activate the prompter if we were waiting
                if (waitingForScript) {
                    waitingForScript = false;
                    activatePrompterMode();
                }
            }
        }

        // Settings change handlers
        document.querySelectorAll('#settings-panel input, #settings-panel select').forEach(el => {
            // Skip elements with their own handlers
            if (el.id === 'setting-saveTranscript' ||
                el.id === 'audio-device-select' ||
                el.id === 'transcription-provider-select' ||
                el.id === 'transcription-model-select') return;

            el.addEventListener('change', () => {
                const newSettings = getSettings();
                applySettings(newSettings);
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'settings', settings: newSettings }));
                }
            });
        });

        // Transcript checkbox handler - just stores the preference locally
        // Recording will start when the prompter is started
        document.getElementById('setting-saveTranscript').addEventListener('change', (e) => {
            // No immediate action - preference is read when prompter starts
        });

        // Initialize
        connect();
    </script>
</body>
</html>
