<!-- Copyright Â© 2025 Ed Nutting | SPDX-License-Identifier: MIT | See LICENSE file for details -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autocue</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Oswald:wght@400;600;700&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --font-size: 48px;
            --font-family: "Merriweather", Georgia, serif;
            --line-height: 1.6;
            --text-color: #FFF8E7;
            --dim-color: #6B4423;
            --highlight-color: #FF8C42;
            --bg-color: #0D0D0D;
            --panel-bg: #1A1A1A;
            --border-color: #2A2A2A;
            --signal-green: #2ECC71;
            --signal-red: #E63946;
            --past-lines: 1;
        }

        @keyframes glow {
            0%, 100% {
                box-shadow: 0 0 5px var(--highlight-color),
                           0 0 10px var(--highlight-color),
                           0 0 15px rgba(255, 140, 66, 0.5);
            }
            50% {
                box-shadow: 0 0 10px var(--highlight-color),
                           0 0 20px var(--highlight-color),
                           0 0 30px rgba(255, 140, 66, 0.7);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        body {
            font-family: "Courier Prime", "Courier New", monospace;
            background: linear-gradient(180deg, #0D0D0D 0%, #1A1A1A 100%);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        /* Editor Mode */
        #editor-container {
            display: flex;
            height: 100vh;
            background: var(--bg-color);
        }

        #editor-panel {
            flex: 1;
            padding: 32px;
            display: flex;
            flex-direction: column;
            border-right: 3px solid var(--border-color);
            background: linear-gradient(135deg, #0D0D0D 0%, #1A1A1A 100%);
            position: relative;
        }

        #editor-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at top left, rgba(255, 140, 66, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        #settings-panel {
            width: 380px;
            padding: 32px;
            overflow-y: auto;
            background: var(--panel-bg);
            border-left: 1px solid rgba(255, 140, 66, 0.2);
            box-shadow: inset 5px 0 15px rgba(0, 0, 0, 0.5);
        }

        #script-input {
            flex: 1;
            width: 100%;
            background: #0A0A0A;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-color);
            font-family: "Courier Prime", monospace;
            font-size: 15px;
            line-height: 1.7;
            padding: 24px;
            resize: none;
            outline: none;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.6);
            transition: border-color 0.3s ease;
            position: relative;
            z-index: 1;
        }

        #script-input:focus {
            border-color: var(--highlight-color);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.6),
                        0 0 0 1px var(--highlight-color);
        }

        #script-input::placeholder {
            color: #4A4A4A;
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }

        .editor-title {
            font-family: "Oswald", sans-serif;
            font-size: 12px;
            font-weight: 600;
            color: var(--highlight-color);
            text-transform: uppercase;
            letter-spacing: 2px;
            padding: 8px 12px;
            background: rgba(255, 140, 66, 0.1);
            border: 1px solid rgba(255, 140, 66, 0.3);
            border-radius: 2px;
        }

        .btn {
            font-family: "Oswald", sans-serif;
            font-size: 14px;
            font-weight: 600;
            padding: 12px 24px;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: var(--highlight-color);
            border-color: var(--highlight-color);
            color: #0D0D0D;
            box-shadow: 0 4px 15px rgba(255, 140, 66, 0.4);
        }

        .btn-primary:hover {
            background: #FFA057;
            border-color: #FFA057;
            box-shadow: 0 6px 20px rgba(255, 140, 66, 0.6);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: transparent;
            border-color: var(--border-color);
            color: var(--text-color);
        }

        .btn-secondary:hover {
            border-color: var(--highlight-color);
            color: var(--highlight-color);
            background: rgba(255, 140, 66, 0.05);
        }

        .icon-btn {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            color: #666;
            opacity: 0.6;
            transition: color 0.2s ease, opacity 0.2s ease, transform 0.1s ease;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 140%;
        }

        .icon-btn:hover {
            color: var(--highlight-color);
            opacity: 1;
            transform: scale(1.1);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .settings-section {
            margin-bottom: 32px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            position: relative;
        }

        .settings-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, var(--highlight-color) 0%, transparent 100%);
        }

        .settings-title {
            font-family: "Oswald", sans-serif;
            font-size: 13px;
            font-weight: 700;
            color: var(--highlight-color);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 140, 66, 0.2);
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
        }

        .setting-label {
            font-family: "Courier Prime", monospace;
            font-size: 14px;
            color: #AAA;
            letter-spacing: 0.5px;
        }

        .setting-input {
            width: 80px;
            padding: 8px 12px;
            background: #0A0A0A;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--highlight-color);
            font-family: "Courier Prime", monospace;
            font-size: 14px;
            text-align: right;
            font-weight: 700;
            transition: all 0.3s ease;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--highlight-color);
            box-shadow: 0 0 8px rgba(255, 140, 66, 0.3);
        }

        .setting-select {
            padding: 8px 12px;
            background: #0A0A0A;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-color);
            font-family: "Courier Prime", monospace;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .setting-select:focus {
            outline: none;
            border-color: var(--highlight-color);
            box-shadow: 0 0 8px rgba(255, 140, 66, 0.3);
        }

        .color-input {
            width: 50px;
            height: 32px;
            border: 2px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-input:hover {
            border-color: var(--highlight-color);
            box-shadow: 0 0 8px rgba(255, 140, 66, 0.3);
        }

        /* Prompter Mode */
        #prompter-container {
            display: none;
            height: 100vh;
            flex-direction: column;
            justify-content: flex-start;
            padding: 5vh 10vw;
            position: relative;
            overflow-y: auto;
            background: #000000;
        }

        #prompter-container.active {
            display: flex;
        }

        #script-display {
            max-height: 80vh;
            overflow-y: auto;
            padding-bottom: 40vh;
            font-family: var(--font-family);
            font-size: var(--font-size);
            line-height: var(--line-height);
        }

        #script-display p {
            margin: 0.3em 0;
        }

        #editor-container.hidden {
            display: none;
        }

        .script-line {
            transition: all 0.15s ease-out;
            padding: 0.1em 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .script-line.past {
            color: var(--dim-color);
            opacity: 0.5;
        }

        .script-line.current {
            color: var(--highlight-color);
        }

        .script-line.future {
            color: var(--text-color);
        }

        .word {
            display: inline;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .word:hover {
            color: var(--highlight-color);
        }

        .word.spoken {
            color: var(--dim-color);
        }

        .word.current {
            color: var(--highlight-color);
        }

        /* Markdown styles for prompter */
        #script-display h1,
        #script-display h2,
        #script-display h3,
        #script-display h4,
        #script-display h5,
        #script-display h6 {
            margin: 0.3em 0;
            font-weight: 700;
            font-family: "Oswald", sans-serif;
            letter-spacing: 1px;
        }

        /* Visual indicator for skipped headers */
        #script-display.skip-headers h1::before,
        #script-display.skip-headers h2::before,
        #script-display.skip-headers h3::before,
        #script-display.skip-headers h4::before,
        #script-display.skip-headers h5::before,
        #script-display.skip-headers h6::before {
            content: "âŠ˜ ";
            color: #666;
            font-size: 0.8em;
            margin-right: 0.3em;
        }

        #script-display h1 { font-size: 1.5em; color: var(--text-color); }
        #script-display h2 { font-size: 1.3em; color: var(--text-color); }
        #script-display h3 { font-size: 1.15em; }

        #script-display strong,
        #script-display b {
            font-weight: 700;
            color: var(--text-color);
        }

        #script-display em,
        #script-display i {
            font-style: italic;
            color: #FFA057;
        }

        #script-display ul,
        #script-display ol {
            margin: 0.2em 0;
            padding-left: 1.5em;
        }

        #script-display li {
            margin: 0.1em 0;
        }

        #script-display blockquote {
            border-left: 4px solid var(--highlight-color);
            padding-left: 1em;
            margin: 0.5em 0;
            opacity: 0.9;
            background: rgba(255, 140, 66, 0.05);
            padding: 0.8em 1em;
        }

        #script-display code {
            font-family: "Courier Prime", monospace;
            background: rgba(255, 140, 66, 0.15);
            padding: 0.2em 0.4em;
            border-radius: 2px;
            color: var(--highlight-color);
        }

        #script-display hr {
            border: none;
            border-top: 2px solid var(--highlight-color);
            margin: 1em 0;
            opacity: 0.3;
        }

        /* Progress bar - analog VU meter style */
        #progress-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            height: 6px;
            background: linear-gradient(90deg,
                var(--signal-green) 0%,
                var(--highlight-color) 50%,
                var(--signal-red) 100%);
            transition: width 0.2s ease;
            z-index: 10000;
        }

        #progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 20px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5));
        }

        /* Status indicator - broadcast style */
        #status {
            position: fixed;
            top: 24px;
            right: 24px;
            font-family: "Oswald", sans-serif;
            font-size: 11px;
            font-weight: 600;
            padding: 12px 18px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--border-color);
            border-radius: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .status-dot.listening {
            background: var(--signal-green);
            box-shadow: 0 0 10px var(--signal-green),
                       0 0 20px rgba(46, 204, 113, 0.5),
                       inset 0 1px 2px rgba(255, 255, 255, 0.3);
            animation: pulse 1.5s infinite;
        }

        .status-dot.backtrack {
            background: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color),
                       0 0 20px rgba(255, 140, 66, 0.5);
        }

        /* Exit button */
        #exit-btn,
        #transcript-btn,
        #fullscreen-btn {
            position: fixed;
            top: 24px;
            font-family: "Oswald", sans-serif;
            font-size: 11px;
            font-weight: 600;
            padding: 12px 18px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--border-color);
            border-radius: 2px;
            color: #AAA;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #exit-btn {
            left: 24px;
        }

        /* Transcript toggle button */
        #transcript-btn {
            left: 140px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Fullscreen button */
        #fullscreen-btn {
            left: 300px;
        }

        /* Timer display */
        #timer-display {
            position: fixed;
            top: 24px;
            left: 420px;
            font-family: "Courier Prime", monospace;
            font-size: 18px;
            font-weight: 700;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--border-color);
            border-radius: 2px;
            color: var(--highlight-color);
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            min-width: 100px;
            text-align: center;
        }

        #timer-display.paused {
            color: #AAA;
            border-color: #666;
        }

        #exit-btn:hover,
        #transcript-btn:hover,
        #fullscreen-btn:hover {
            border-color: var(--highlight-color);
            color: var(--highlight-color);
            background: rgba(255, 140, 66, 0.1);
            box-shadow: 0 4px 20px rgba(255, 140, 66, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #transcript-btn.recording {
            background: rgba(230, 57, 70, 0.2);
            border-color: var(--signal-red);
            color: var(--signal-red);
        }

        #transcript-btn.recording:hover {
            background: rgba(230, 57, 70, 0.3);
            box-shadow: 0 4px 20px rgba(230, 57, 70, 0.4);
        }

        .record-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
        }

        .record-dot.active {
            background: var(--signal-red);
            box-shadow: 0 0 10px var(--signal-red),
                       0 0 20px rgba(230, 57, 70, 0.5);
            animation: pulse 1s infinite;
        }

        /* Transcript display */
        #transcript {
            position: fixed;
            bottom: 30px;
            left: 24px;
            right: 24px;
            font-family: "Courier Prime", monospace;
            font-size: 13px;
            color: #666;
            text-align: center;
            max-height: 60px;
            overflow: hidden;
            letter-spacing: 0.5px;
        }

        /* Loading spinner overlay */
        #loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(13, 13, 13, 0.98);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 32px;
        }

        #loading-overlay.visible {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 140, 66, 0.2);
            border-top-color: var(--highlight-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 20px rgba(255, 140, 66, 0.3);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: "Oswald", sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: var(--highlight-color);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .loading-model {
            font-family: "Courier Prime", monospace;
            font-size: 12px;
            color: #666;
            text-align: center;
            letter-spacing: 1px;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #0A0A0A;
            border-left: 1px solid var(--border-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--highlight-color);
            border: 2px solid #0A0A0A;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #FFA057;
        }
    </style>
</head>
<body>
    <!-- Editor Mode -->
    <div id="editor-container">
        <div id="editor-panel">
            <div class="editor-header">
                <span class="editor-title">â—‰ REC / Script Input</span>
                <div style="display: flex; gap: 14px; align-items: center;">
                    <button class="icon-btn" onclick="refreshScripts()" title="Refresh scripts list">âŸ³</button>
                    <select class="setting-select" id="sample-select" style="min-width: 200px;">
                        <option value="">Load script...</option>
                    </select>
                    <button class="btn btn-primary" onclick="startPrompter()">â–¶ Start Broadcast</button>
                </div>
            </div>
            <textarea id="script-input" placeholder="// PASTE YOUR SCRIPT HERE

You can use **Markdown** formatting:
- Headers with #
- **Bold** and *italic*
- Lists and paragraphs

The prompter will track your speech and scroll automatically.

Ready when you are."></textarea>
        </div>

        <div id="settings-panel">
            <div class="settings-section">
                <div class="settings-title">âš¡ Typography</div>
                <div class="setting-row">
                    <span class="setting-label">Font Size</span>
                    <input type="number" class="setting-input" id="setting-fontSize" value="48" min="24" max="120">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Font</span>
                    <select class="setting-select" id="setting-fontFamily" style="width: 100%;">
                        <option value='"Merriweather", Georgia, serif'>Merriweather</option>
                        <option value='"Crimson Pro", Georgia, serif'>Crimson Pro</option>
                        <option value='"Playfair Display", Georgia, serif'>Playfair Display</option>
                        <option value='Georgia, serif'>Georgia</option>
                        <option value='system-ui, sans-serif'>System</option>
                    </select>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Line Height</span>
                    <input type="number" class="setting-input" id="setting-lineHeight" value="1.6" min="1" max="3" step="0.1">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">âš¡ Display</div>
                <div class="setting-row">
                    <span class="setting-label">Past Lines</span>
                    <input type="number" class="setting-input" id="setting-pastLines" value="1" min="0" max="5">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Future Lines</span>
                    <input type="number" class="setting-input" id="setting-futureLines" value="8" min="3" max="20">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">âš¡ Tracking</div>
                <div class="setting-row">
                    <span class="setting-label">Skip Headers</span>
                    <input type="checkbox" id="setting-skipHeaders" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--highlight-color);">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">âš¡ Recording</div>
                <div class="setting-row">
                    <span class="setting-label">Save Transcript</span>
                    <input type="checkbox" id="setting-saveTranscript" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--highlight-color);">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">âš¡ Audio Device</div>
                <div class="setting-row" style="flex-direction: column; align-items: flex-start; gap: 10px;">
                    <span class="setting-label">Input Device</span>
                    <select class="setting-select" id="audio-device-select" style="width: 100%;">
                        <option value="">Loading devices...</option>
                    </select>
                    <span id="audio-device-status" style="font-family: 'Courier Prime', monospace; font-size: 10px; color: #666;"></span>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">âš¡ Transcription</div>
                <div class="setting-row" style="flex-direction: column; align-items: flex-start; gap: 10px;">
                    <span class="setting-label">Provider</span>
                    <select class="setting-select" id="transcription-provider-select" style="width: 100%;">
                        <option value="vosk">Vosk</option>
                        <option value="sherpa">Sherpa-ONNX</option>
                    </select>
                </div>
                <div class="setting-row" style="flex-direction: column; align-items: flex-start; gap: 10px; margin-top: 12px;">
                    <span class="setting-label">Model</span>
                    <select class="setting-select" id="transcription-model-select" style="width: 100%;">
                        <option value="">Loading models...</option>
                    </select>
                    <span id="transcription-status" style="font-family: 'Courier Prime', monospace; font-size: 10px; color: #666;"></span>
                    <div id="model-download-progress" style="display: none; width: 100%; margin-top: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <span id="model-download-stage" style="font-family: 'Courier Prime', monospace; font-size: 10px; color: #AAA;">Downloading...</span>
                            <span id="model-download-percent" style="font-family: 'Courier Prime', monospace; font-size: 10px; color: var(--highlight-color); font-weight: 700;">0%</span>
                        </div>
                        <div style="width: 100%; height: 6px; background: #0A0A0A; border: 1px solid var(--border-color); border-radius: 2px; overflow: hidden;">
                            <div id="model-download-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--signal-green), var(--highlight-color)); transition: width 0.3s ease; box-shadow: 0 0 10px rgba(255, 140, 66, 0.6);"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">âš¡ Colors</div>
                <div class="setting-row">
                    <span class="setting-label">Highlight</span>
                    <input type="color" class="color-input" id="setting-highlightColor" value="#FF8C42">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Text</span>
                    <input type="color" class="color-input" id="setting-textColor" value="#FFF8E7">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Dim</span>
                    <input type="color" class="color-input" id="setting-dimColor" value="#6B4423">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Background</span>
                    <input type="color" class="color-input" id="setting-backgroundColor" value="#0D0D0D">
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">âš¡ Keyboard Shortcuts</div>
                <div class="setting-row">
                    <span class="setting-label" style="color: var(--highlight-color); font-weight: 700;">[ESC]</span>
                    <span class="setting-label">Exit prompter</span>
                </div>
                <div class="setting-row">
                    <span class="setting-label" style="color: var(--highlight-color); font-weight: 700;">[SPACE]</span>
                    <span class="setting-label">Pause/Resume</span>
                </div>
                <div class="setting-row">
                    <span class="setting-label" style="color: var(--highlight-color); font-weight: 700;">[R]</span>
                    <span class="setting-label">Reset to start</span>
                </div>
                <div class="setting-row">
                    <span class="setting-label" style="color: var(--highlight-color); font-weight: 700;">[F]</span>
                    <span class="setting-label">Toggle fullscreen</span>
                </div>
            </div>

            <div class="settings-section">
                <button class="btn btn-secondary" id="save-config-btn" onclick="saveConfig()" style="width: 100%;">ðŸ’¾ Save as Default</button>
                <div id="save-status" style="font-family: 'Courier Prime', monospace; font-size: 11px; color: #666; margin-top: 12px; text-align: center;"></div>
            </div>
        </div>
    </div>

    <!-- Prompter Mode -->
    <div id="prompter-container">
        <div id="script-display"></div>
        <div id="progress-bar" style="width: 0%"></div>
        <div id="status">
            <span class="status-dot listening"></span>
            <span id="status-text">On Air</span>
        </div>
        <button id="exit-btn" onclick="exitPrompter()">â—¼ Stop</button>
        <button id="transcript-btn" onclick="toggleTranscript()">
            <span class="record-dot"></span>
            <span id="transcript-btn-text">Transcribe</span>
        </button>
        <button id="fullscreen-btn" onclick="toggleFullscreen()">â›¶ Full</button>
        <div id="timer-display">00:00</div>
        <div id="transcript"></div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">â—‰ Loading Model...</div>
        <div class="loading-model" id="loading-model-name"></div>
    </div>

    <script>
        let ws = null;
        let totalWords = 0;  // Set by server
        let currentWordIndex = 0;
        let settings = {};
        let isPaused = false;
        let scriptHtml = '';  // Pre-indexed HTML from server
        let isRecordingTranscript = false;  // Transcript recording state
        let audioDevices = [];  // Available audio devices
        let currentAudioDevice = null;  // Currently selected audio device index
        let transcriptionModels = [];  // Available transcription models
        let currentTranscriptionConfig = null;  // Current transcription configuration
        let waitingForModelLoad = false;  // Track if we're waiting for model to load
        let timerStartTime = null;  // Timer start timestamp
        let timerElapsed = 0;  // Accumulated elapsed time in milliseconds
        let timerInterval = null;  // Timer update interval

        // Connect WebSocket
        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => console.log('WebSocket connected');
            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(connect, 1000);
            };
            ws.onerror = (e) => console.error('WebSocket error:', e);

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
        }

        function handleMessage(data) {
            switch (data.type) {
                case 'init':
                    document.getElementById('script-input').value = data.script || '';
                    scriptHtml = data.scriptHtml || '';
                    totalWords = data.totalWords || 0;
                    settings = data.settings || {};
                    applySettings(settings);
                    // Populate sample scripts dropdown
                    populateSamples(data.samples || []);
                    // Store current audio device
                    currentAudioDevice = data.audioDevice;
                    // Fetch and populate audio devices
                    fetchAudioDevices();
                    // Store transcription config and fetch models
                    currentTranscriptionConfig = data.transcriptionConfig;
                    if (currentTranscriptionConfig) {
                        document.getElementById('transcription-provider-select').value = currentTranscriptionConfig.provider;
                    }
                    fetchTranscriptionModels();
                    break;

                case 'script_updated':
                    document.getElementById('script-input').value = data.script;
                    scriptHtml = data.scriptHtml || '';
                    totalWords = data.totalWords || 0;
                    // If we were waiting to start the prompter, activate it now
                    // (unless we're waiting for the model to load)
                    if (waitingForScript && !waitingForModelLoad) {
                        waitingForScript = false;
                        activatePrompterMode();
                    }
                    break;

                case 'settings_updated':
                    settings = data.settings;
                    applySettings(settings);
                    break;

                case 'position':
                    updatePosition(data);
                    break;

                case 'reset':
                    resetDisplay();
                    break;

                case 'jump_to':
                    jumpToWord(data.wordIndex);
                    break;

                case 'config_saved': {
                        const statusEl = document.getElementById('save-status');
                        if (data.success) {
                            statusEl.textContent = 'âœ“ SETTINGS SAVED';
                            statusEl.style.color = 'var(--signal-green)';
                        } else {
                            statusEl.textContent = 'âœ— ERROR: ' + (data.error || 'Unknown error');
                            statusEl.style.color = 'var(--signal-red)';
                        }
                        setTimeout(() => { statusEl.textContent = ''; }, 3000);
                    }
                    break;

                case 'transcript_status':
                    updateTranscriptUI(data.recording, data.file);
                    break;

                case 'audio_device_updated': {
                        const statusEl = document.getElementById('audio-device-status');
                        if (data.success) {
                            currentAudioDevice = data.deviceIndex;
                            statusEl.textContent = 'âœ“ Device updated. Restart prompter.';
                            statusEl.style.color = 'var(--signal-green)';
                        } else {
                            statusEl.textContent = 'âœ— Failed: ' + (data.error || 'Unknown error');
                            statusEl.style.color = 'var(--signal-red)';
                        }
                        setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    }
                    break;

                case 'transcription_models':
                    transcriptionModels = data.models || [];
                    const provider = document.getElementById('transcription-provider-select').value;
                    populateTranscriptionModels(provider);
                    break;

                case 'transcription_config_updated': {
                        const statusEl = document.getElementById('transcription-status');
                        if (data.success) {
                            statusEl.textContent = data.message || 'âœ“ Saved. Restart to apply.';
                            statusEl.style.color = 'var(--signal-green)';
                        } else {
                            statusEl.textContent = data.error || 'âœ— Failed to save';
                            statusEl.style.color = 'var(--signal-red)';
                        }
                        setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    }
                    break;

                case 'model_download_status':
                    handleModelDownloadStatus(data);
                    break;

                case 'model_download_progress':
                    handleModelDownloadProgress(data);
                    break;

                case 'model_download_complete':
                    handleModelDownloadComplete(data);
                    break;

                case 'model_loading_status':
                    handleModelLoadingStatus(data);
                    break;

                case 'scripts_refreshed':
                    populateSamples(data.samples || []);
                    break;
            }
        }

        function updateTranscriptUI(recording, file) {
            isRecordingTranscript = recording;
            const btn = document.getElementById('transcript-btn');
            const btnText = document.getElementById('transcript-btn-text');
            const dot = btn.querySelector('.record-dot');
            const checkbox = document.getElementById('setting-saveTranscript');

            if (recording) {
                btn.classList.add('recording');
                dot.classList.add('active');
                btnText.textContent = 'Transcribing';
                if (checkbox) checkbox.checked = true;
            } else {
                btn.classList.remove('recording');
                dot.classList.remove('active');
                btnText.textContent = 'Transcribe';
                if (checkbox) checkbox.checked = false;
            }
        }

        function toggleTranscript() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'toggle_transcript',
                    enable: !isRecordingTranscript
                }));
            }
        }

        function toggleFullscreen() {
            const prompter = document.getElementById('prompter-container');

            if (!document.fullscreenElement) {
                // Enter fullscreen
                if (prompter.requestFullscreen) {
                    prompter.requestFullscreen();
                } else if (prompter.webkitRequestFullscreen) {
                    prompter.webkitRequestFullscreen();
                } else if (prompter.msRequestFullscreen) {
                    prompter.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // Update fullscreen button text when fullscreen state changes
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
        document.addEventListener('msfullscreenchange', updateFullscreenButton);

        function updateFullscreenButton() {
            const btn = document.getElementById('fullscreen-btn');
            if (document.fullscreenElement) {
                btn.textContent = 'â›¶ Exit';
            } else {
                btn.textContent = 'â›¶ Full';
            }
        }

        function applySettings(s) {
            const root = document.documentElement;
            root.style.setProperty('--font-size', s.fontSize + 'px');
            root.style.setProperty('--font-family', s.fontFamily);
            root.style.setProperty('--line-height', s.lineHeight);
            root.style.setProperty('--highlight-color', s.highlightColor);
            root.style.setProperty('--text-color', s.textColor);
            root.style.setProperty('--dim-color', s.dimColor);
            root.style.setProperty('--bg-color', s.backgroundColor);

            // Update input values
            for (const [key, value] of Object.entries(s)) {
                const el = document.getElementById('setting-' + key);
                if (el) {
                    if (el.type === 'checkbox') {
                        el.checked = value;
                    } else {
                        el.value = value;
                    }
                }
            }

            // Apply skip-headers class to script display
            const scriptDisplay = document.getElementById('script-display');
            if (s.skipHeaders) {
                scriptDisplay.classList.add('skip-headers');
            } else {
                scriptDisplay.classList.remove('skip-headers');
            }
        }

        function getSettings() {
            return {
                fontSize: parseInt(document.getElementById('setting-fontSize').value),
                fontFamily: document.getElementById('setting-fontFamily').value,
                lineHeight: parseFloat(document.getElementById('setting-lineHeight').value),
                pastLines: parseInt(document.getElementById('setting-pastLines').value),
                futureLines: parseInt(document.getElementById('setting-futureLines').value),
                skipHeaders: document.getElementById('setting-skipHeaders').checked,
                highlightColor: document.getElementById('setting-highlightColor').value,
                textColor: document.getElementById('setting-textColor').value,
                dimColor: document.getElementById('setting-dimColor').value,
                backgroundColor: document.getElementById('setting-backgroundColor').value
            };
        }

        function saveConfig() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const statusEl = document.getElementById('save-status');
                statusEl.textContent = 'âŸ³ SAVING...';
                statusEl.style.color = '#666';
                ws.send(JSON.stringify({ type: 'save_config' }));
            }
        }

        // Flag to indicate we're waiting for server to send indexed HTML
        let waitingForScript = false;

        function startPrompter() {
            const script = document.getElementById('script-input').value.trim();
            if (!script) {
                alert('Please enter a script first');
                return;
            }

            // Send script and settings to server
            // The server will respond with indexed HTML in script_updated message
            settings = getSettings();
            waitingForScript = true;

            // Get transcript preference
            const saveTranscript = document.getElementById('setting-saveTranscript').checked;

            // Send script to load it (without saveTranscript, as we'll send start_prompting separately)
            ws.send(JSON.stringify({ type: 'script', text: script }));
            ws.send(JSON.stringify({ type: 'settings', settings: settings }));

            // Send start_prompting to initialize audio and transcriber
            ws.send(JSON.stringify({ type: 'start_prompting', saveTranscript: saveTranscript }));
        }

        function activatePrompterMode() {
            // Switch to prompter mode
            document.getElementById('editor-container').classList.add('hidden');
            document.getElementById('prompter-container').classList.add('active');

            // Initial render using server-provided indexed HTML
            currentWordIndex = 0;
            renderScriptByWordIndex(0);

            // Apply settings
            applySettings(settings);

            // Start the timer
            startTimer();
        }

        function exitPrompter() {
            // Send stop_prompting to cleanup audio and transcriber
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'stop_prompting' }));
            }

            // Stop the timer
            stopTimer();

            document.getElementById('editor-container').classList.remove('hidden');
            document.getElementById('prompter-container').classList.remove('active');
        }

        function renderScriptByWordIndex(wordIndex) {
            const display = document.getElementById('script-display');

            // Render the pre-indexed HTML from server
            // Note: scriptHtml comes from trusted server-side processing of user's own script
            display.innerHTML = scriptHtml;

            // Update word styling based on current position
            display.querySelectorAll('.word').forEach(el => {
                const wordIdx = parseInt(el.dataset.wordIndex, 10);
                el.classList.remove('spoken', 'current');

                if (wordIdx < wordIndex) {
                    el.classList.add('spoken');
                } else if (wordIdx === wordIndex) {
                    el.classList.add('current');
                }

                // Add click handler
                el.addEventListener('click', handleWordClick);
            });

            // Scroll the current word into view
            const currentEl = display.querySelector('.word.current');
            if (currentEl) {
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function handleWordClick(e) {
            const wordIndex = parseInt(e.target.dataset.wordIndex, 10);
            if (!isNaN(wordIndex)) {
                ws.send(JSON.stringify({ type: 'jump_to', wordIndex: wordIndex }));
            }
        }

        function jumpToWord(wordIndex) {
            currentWordIndex = wordIndex;
            renderScriptByWordIndex(wordIndex);

            // Update progress bar
            const progress = totalWords > 0 ? (wordIndex / totalWords) * 100 : 0;
            document.getElementById('progress-bar').style.width = progress + '%';
        }

        function updatePosition(data) {
            if (isPaused) return;

            // Use wordIndex directly - no line/offset conversion needed
            // since we use server-provided word indices in the HTML
            currentWordIndex = data.wordIndex;
            renderScriptByWordIndex(data.wordIndex);

            // Report what word we're highlighting back to server for debugging
            const currentEl = document.querySelector('.word.current');
            if (currentEl && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'frontend_highlight',
                    wordIndex: data.wordIndex,
                    word: currentEl.textContent,
                    sourceLine: data.lineIndex,
                    sourceOffset: data.wordOffset,
                    serverWordIndex: data.wordIndex
                }));
            }

            // Update progress bar
            const progress = totalWords > 0 ? (data.wordIndex / totalWords) * 100 : 0;
            document.getElementById('progress-bar').style.width = progress + '%';

            // Update status
            const dot = document.querySelector('.status-dot');
            const statusText = document.getElementById('status-text');

            if (data.isBacktrack) {
                dot.className = 'status-dot backtrack';
                statusText.textContent = 'Rewind';
                setTimeout(() => {
                    dot.className = 'status-dot listening';
                    statusText.textContent = 'On Air';
                }, 1000);
            } else if (data.confidence > 70) {
                dot.className = 'status-dot listening';
                statusText.textContent = 'On Air';
            }

            // Show transcript
            if (data.transcript) {
                document.getElementById('transcript').textContent = '> ' + data.transcript;
            }
        }

        function resetDisplay() {
            currentWordIndex = 0;
            renderScriptByWordIndex(0);
            document.getElementById('progress-bar').style.width = '0%';
            // Reset timer - restart only if not paused
            stopTimer();
            if (!isPaused) {
                startTimer();
            } else {
                // Keep paused styling when reset while paused
                document.getElementById('timer-display').classList.add('paused');
            }
        }

        // Timer functions
        function startTimer() {
            timerStartTime = Date.now();
            timerElapsed = 0;
            updateTimerDisplay();
            timerInterval = setInterval(updateTimerDisplay, 100);  // Update every 100ms for smooth display
            document.getElementById('timer-display').classList.remove('paused');
        }

        function pauseTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            // Accumulate elapsed time
            if (timerStartTime) {
                timerElapsed += Date.now() - timerStartTime;
                timerStartTime = null;
            }
            document.getElementById('timer-display').classList.add('paused');
        }

        function resumeTimer() {
            timerStartTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 100);
            document.getElementById('timer-display').classList.remove('paused');
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerStartTime = null;
            timerElapsed = 0;
            document.getElementById('timer-display').textContent = '00:00';
            document.getElementById('timer-display').classList.remove('paused');
        }

        function updateTimerDisplay() {
            let totalMs = timerElapsed;
            if (timerStartTime) {
                totalMs += Date.now() - timerStartTime;
            }

            const totalSeconds = Math.floor(totalMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;

            const display = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('timer-display').textContent = display;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('prompter-container').classList.contains('active')) {
                return;
            }

            switch (e.key) {
                case 'Escape':
                    exitPrompter();
                    break;
                case ' ':
                    e.preventDefault();
                    isPaused = !isPaused;
                    document.getElementById('status-text').textContent = isPaused ? 'Paused' : 'On Air';
                    // Pause/resume the timer
                    if (isPaused) {
                        pauseTimer();
                    } else {
                        resumeTimer();
                    }
                    break;
                case 'r':
                case 'R':
                    ws.send(JSON.stringify({ type: 'reset' }));
                    resetDisplay();
                    break;
                case 'f':
                case 'F':
                    toggleFullscreen();
                    break;
            }
        });

        // Populate sample scripts dropdown
        function populateSamples(samples) {
            const select = document.getElementById('sample-select');
            // Clear existing options and optgroups, keeping only the first placeholder
            const placeholder = select.options[0];
            select.innerHTML = '';
            select.appendChild(placeholder);

            // Handle both old format (flat array) and new format (grouped object)
            if (Array.isArray(samples)) {
                // Old format - flat array
                samples.forEach(sample => {
                    const option = document.createElement('option');
                    option.value = sample.filename;
                    option.textContent = sample.name;
                    option.dataset.source = sample.source || 'samples';
                    select.appendChild(option);
                });
            } else {
                // New format - grouped object
                // Add sample scripts group
                if (samples.samples && samples.samples.length > 0) {
                    const samplesGroup = document.createElement('optgroup');
                    samplesGroup.label = 'Sample Scripts';
                    samples.samples.forEach(sample => {
                        const option = document.createElement('option');
                        option.value = sample.filename;
                        option.textContent = sample.name;
                        option.dataset.source = sample.source;
                        samplesGroup.appendChild(option);
                    });
                    select.appendChild(samplesGroup);
                }

                // Add extra scripts group
                if (samples.extras && samples.extras.length > 0) {
                    const extrasGroup = document.createElement('optgroup');
                    extrasGroup.label = 'My Scripts';
                    samples.extras.forEach(sample => {
                        const option = document.createElement('option');
                        option.value = sample.filename;
                        option.textContent = sample.name;
                        option.dataset.source = sample.source;
                        extrasGroup.appendChild(option);
                    });
                    select.appendChild(extrasGroup);
                }
            }
        }

        // Sample script selection handler
        document.getElementById('sample-select').addEventListener('change', (e) => {
            const filename = e.target.value;
            const selectedOption = e.target.selectedOptions[0];
            const source = selectedOption?.dataset?.source || 'samples';
            if (filename && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'load_sample', filename: filename, source: source }));
            }
            // Reset dropdown to placeholder
            e.target.value = '';
        });

        // Refresh scripts list
        function refreshScripts() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'refresh_scripts' }));
            }
        }

        // Fetch audio devices from backend
        async function fetchAudioDevices() {
            try {
                const response = await fetch('/audio-devices');
                const data = await response.json();
                if (data.status === 'ok') {
                    audioDevices = data.devices;
                    populateAudioDevices();
                } else {
                    console.error('Failed to fetch audio devices:', data.message);
                    document.getElementById('audio-device-select').innerHTML = '<option value="">Error loading devices</option>';
                }
            } catch (error) {
                console.error('Error fetching audio devices:', error);
                document.getElementById('audio-device-select').innerHTML = '<option value="">Error loading devices</option>';
            }
        }

        // Populate audio devices dropdown
        function populateAudioDevices() {
            const select = document.getElementById('audio-device-select');
            select.innerHTML = '';

            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'System Default';
            select.appendChild(defaultOption);

            // Add device options
            audioDevices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.index;
                option.textContent = device.name;
                select.appendChild(option);
            });

            // Set current selection
            if (currentAudioDevice !== null && currentAudioDevice !== undefined) {
                select.value = currentAudioDevice;
            } else {
                select.value = '';
            }
        }

        // Audio device selection handler
        document.getElementById('audio-device-select').addEventListener('change', (e) => {
            const deviceIndex = e.target.value === '' ? null : parseInt(e.target.value);
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'set_audio_device',
                    deviceIndex: deviceIndex
                }));
            }
        });

        // Fetch transcription models from backend
        function fetchTranscriptionModels() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'get_transcription_models' }));
            }
        }

        // Populate transcription model dropdown based on selected provider
        function populateTranscriptionModels(provider) {
            const select = document.getElementById('transcription-model-select');
            select.innerHTML = '';

            const filtered = transcriptionModels.filter(m => m.provider === provider);
            if (filtered.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No models available';
                select.appendChild(option);
                return;
            }

            filtered.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = `${model.name} (${model.sizeMb}MB)`;
                select.appendChild(option);
            });

            // Select current model if available
            if (currentTranscriptionConfig && currentTranscriptionConfig.provider === provider) {
                select.value = currentTranscriptionConfig.model_id;
            } else if (filtered.length > 0) {
                select.value = filtered[0].id;
            }
        }

        // Transcription provider selection handler
        document.getElementById('transcription-provider-select').addEventListener('change', (e) => {
            populateTranscriptionModels(e.target.value);
        });

        // Transcription model selection handler
        document.getElementById('transcription-model-select').addEventListener('change', (e) => {
            const provider = document.getElementById('transcription-provider-select').value;
            const modelId = e.target.value;

            if (ws && ws.readyState === WebSocket.OPEN) {
                // First check if model is downloaded
                ws.send(JSON.stringify({
                    type: 'check_model_downloaded',
                    provider: provider,
                    modelId: modelId
                }));
            }
        });

        // Handle model download status check
        function handleModelDownloadStatus(data) {
            const provider = data.provider;
            const modelId = data.modelId;
            const downloaded = data.downloaded;

            if (downloaded) {
                // Model is already downloaded, just save the config
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'set_transcription_config',
                        provider: provider,
                        modelId: modelId
                    }));
                }
            } else {
                // Model not downloaded, start download automatically
                const statusEl = document.getElementById('transcription-status');
                statusEl.textContent = 'âŸ³ Downloading model...';
                statusEl.style.color = 'var(--highlight-color)';

                // Start download
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'download_model',
                        provider: provider,
                        modelId: modelId
                    }));
                }

                // Show progress bar
                showModelDownloadProgress();
            }
        }

        // Handle model download progress updates
        function handleModelDownloadProgress(data) {
            const stage = data.stage;
            const percent = data.percent;

            // Update progress bar
            const progressContainer = document.getElementById('model-download-progress');
            const stageEl = document.getElementById('model-download-stage');
            const percentEl = document.getElementById('model-download-percent');
            const barEl = document.getElementById('model-download-bar');

            progressContainer.style.display = 'block';

            // Update stage text
            const stageText = {
                'starting': 'âŸ³ Starting...',
                'downloading': 'â¬‡ Downloading...',
                'extracting': 'ðŸ“¦ Extracting...',
                'complete': 'âœ“ Complete'
            };
            stageEl.textContent = stageText[stage] || stage;
            percentEl.textContent = percent + '%';
            barEl.style.width = percent + '%';
        }

        // Handle model download completion
        function handleModelDownloadComplete(data) {
            const statusEl = document.getElementById('transcription-status');

            if (data.success) {
                statusEl.textContent = data.message || 'âœ“ Downloaded. Restart to use.';
                statusEl.style.color = 'var(--signal-green)';

                // Hide progress bar after a delay
                setTimeout(() => {
                    hideModelDownloadProgress();
                }, 2000);

                // Save the config now that model is downloaded
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'set_transcription_config',
                        provider: data.provider,
                        modelId: data.modelId
                    }));
                }
            } else {
                statusEl.textContent = 'âœ— Download failed: ' + (data.error || 'Unknown');
                statusEl.style.color = 'var(--signal-red)';
                hideModelDownloadProgress();
            }

            setTimeout(() => {
                if (statusEl.textContent.includes('Restart')) {
                    statusEl.textContent = '';
                }
            }, 10000);
        }

        // Show model download progress bar
        function showModelDownloadProgress() {
            const progressContainer = document.getElementById('model-download-progress');
            progressContainer.style.display = 'block';
            document.getElementById('model-download-stage').textContent = 'âŸ³ Starting...';
            document.getElementById('model-download-percent').textContent = '0%';
            document.getElementById('model-download-bar').style.width = '0%';
        }

        // Hide model download progress bar
        function hideModelDownloadProgress() {
            const progressContainer = document.getElementById('model-download-progress');
            progressContainer.style.display = 'none';
        }

        // Handle model loading status
        function handleModelLoadingStatus(data) {
            const overlay = document.getElementById('loading-overlay');
            const modelNameEl = document.getElementById('loading-model-name');

            if (data.status === 'loading') {
                // Show loading spinner
                waitingForModelLoad = true;
                modelNameEl.textContent = `${data.provider} / ${data.modelId}`;
                overlay.classList.add('visible');
            } else if (data.status === 'ready') {
                // Hide loading spinner and activate prompter
                waitingForModelLoad = false;
                overlay.classList.remove('visible');
                // Now that model is ready, activate the prompter if we were waiting
                if (waitingForScript) {
                    waitingForScript = false;
                    activatePrompterMode();
                }
            }
        }

        // Settings change handlers
        document.querySelectorAll('#settings-panel input, #settings-panel select').forEach(el => {
            // Skip elements with their own handlers
            if (el.id === 'setting-saveTranscript' ||
                el.id === 'audio-device-select' ||
                el.id === 'transcription-provider-select' ||
                el.id === 'transcription-model-select') return;

            el.addEventListener('change', () => {
                const newSettings = getSettings();
                applySettings(newSettings);
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'settings', settings: newSettings }));
                }
            });
        });

        // Special handler for skipHeaders - needs to reload tracker
        document.getElementById('setting-skipHeaders').addEventListener('change', (e) => {
            const newSettings = getSettings();
            applySettings(newSettings);
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'update_tracking_settings', skipHeaders: e.target.checked }));
            }
        });

        // Transcript checkbox handler - just stores the preference locally
        // Recording will start when the prompter is started
        document.getElementById('setting-saveTranscript').addEventListener('change', (e) => {
            // No immediate action - preference is read when prompter starts
        });

        // Initialize
        connect();
    </script>
</body>
</html>
